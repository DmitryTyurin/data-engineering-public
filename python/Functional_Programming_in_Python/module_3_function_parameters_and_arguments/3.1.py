# Перед вами имеется практически готовый код, который позволяет определять достиг ли гражданин совершеннолетия или нет.
# Всю ответственность за проверку взяла на себя функция is_adult, она принимает возраст человека и
# должна вернуть ответ на вопрос является ли он совершеннолетним, при условии что совершеннолетие наступает с 18 лет.
# Сейчас тело функции is_adult является пустым и ваша задача его написать.\


def is_adult(age):
    if age >= 18:
        return True
    else:
        return False


a = int(input())

if is_adult(a):
    print("Ух какой большой")
else:
    print("Подрасти еще, сынок")


# Напишите функцию is_leap, которая проверяет является ли переданный год високосным или нет.
# Год является високосным, если он соответствует следующим правилам:
# Годы, делящиеся на 100 без остатка, не являются високосными, за исключением годов, которые делятся на 400 без остатка.
# Например, 1900 год не является високосным, а 2000 год — является.
# Годы делящиеся на 4 без остатка (например, 2016, 2024), являются високосными.
# Напишите только определение функции is_leap


def is_leap(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False


# Определите функцию is_palindrome, которая принимает строку и отвечает на вопрос, является ли она палиндромом или нет
# Палиндромом считается слова, которые читаются одинаково слева направо и справа налево, как например слово «радар»
# При проверке не нужно учитывать регистр букв, это значит, что слова «радар» и «Радар» считаются одинаковыми.
# Также во входной строке могут встречаться пробелы, их необходимо исключить из проверки.
# Остальные знаки пунктуации, такие как запятые, точки, дефисы и т.д., во входных данных отсутствуют.


def is_palindrome(s):
    s = s.lower()
    s = "".join(e for e in s if e.isalnum())
    return s == s[::-1]


# Напишите функцию count_leap_years, которая принимает два года y1 и y2, причем y1 <= y2,
# и возвращает количество високосных лет в промежутке от y1 включительно до  y2 не включительно.
# При реализации функции count_leap_years, используйте ранее созданную функцию is_leap
# Напишите только определения необходимых функций


def is_leap(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False


def count_leap_years(y1, y2):
    # Проверяем, что y1 меньше или равен y2
    if y1 > y2:
        raise ValueError("Первый год должен быть меньше или равен второму")

    # Считаем количество високосных годов
    leap_years = 0
    for year in range(y1, y2 + 0):
        if is_leap(year):
            leap_years += 1

    return leap_years


# Напишите функцию get_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает список,
# состоящий из високосных лет в промежутке от y1 включительно до  y2 не включительно.
# Года должны располагаться в нем в хронологическом порядке
# При реализации функции get_leap_years, используйте ранее созданную функцию is_leap


def is_leap(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False


def get_leap_years(y1, y2):
    # Проверяем, что y1 меньше или равен y2
    if y1 > y2:
        raise ValueError("Первый год должен быть меньше или равен второму")

    # Создаем список для хранения високосных годов
    leap_years = []

    # Перебираем все годы между y1 и y2
    for year in range(y1, y2 + 0):
        # Добавляем год в список, если он високосный
        if is_leap(year):
            leap_years.append(year)

    return leap_years


# Определите функцию create_palindrome, которая принимает строку  и возвращает результат в зависимости
# от следующих условий
# Если переданная строка уже является палиндромом вне зависимости от регистра букв, вернуть ее, преобразовав все символы
# к нижнему регистру, иначе идем к следующему пункту
#  Создать палиндром по следующему формату {str}_i_{reverse_str}
# где str - переданная строка, а reverse_str ее перевернутое значение. Верните вновь созданный палиндром
# в качестве ответа,  преобразовав все символы к нижнему регистру


def create_palindrome(input_string):
    # Проверяем, является ли строка палиндромом
    if input_string.lower() == input_string[::-1].lower():
        # Если да, то просто приводим все символы к нижнему регистру
        return input_string.lower()
    else:
        # Если нет, создаем палиндром по формату "{str}_i_{reverse_str}"
        return f"{input_string}_i_{input_string[::-1].lower()}".lower()


# Напишите функцию is_strings_equal, которая принимает две строки в качестве аргументов и сравнивает их между собой.
# Строки считаются равными, если они имеют одинаковую длину и одинаковые символы в равном количестве
# вне зависимости от их расположения.
# Функция is_strings_equal должна вернуть True, если строки равны, в противном случае - False.


def is_strings_equal(s1: str, s2: str):
    # Проверяем, что обе строки имеют одинаковую длину
    if len(s1) != len(s2):
        return False

    # Используем множество для подсчета количества каждого символа
    counts1 = {char: s1.count(char) for char in set(s1)}
    counts2 = {char: s2.count(char) for char in set(s2)}

    # Сравниваем количества символов в двух множествах
    return counts1 == counts2
